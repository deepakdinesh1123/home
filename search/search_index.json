{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Deepak D","text":"Software Engineer <p>I love type-safe compiled languages, containers, and Nix.</p>"},{"location":"#my-expertise","title":"My Expertise","text":"<ul> <li>Backend Development \u2014 super comfortable with python frameworks such as Django, FastAPI but absolutely love creating my own framework by carefully selecting the kind of dependency I want for a particular thing in go (ex: using sqlc for queries and chi for routing)</li> <li>Environment Management \u2014 Utilizing nix and docker to create the most reproducible dev, test and deployment environments</li> <li>CI/CD Pipelines \u2014 Building efficient workflows for continuous integration, testing, benchmarking and application deployment</li> </ul>"},{"location":"contact/","title":"\ud83d\udcec Contact Me","text":"<p>If you\u2019d like to discuss a project, collaborate, or just say hello, feel free to reach out!  </p>"},{"location":"contact/#email","title":"\ud83d\udce7 Email","text":"<p>You can email me at: d.deepakdinesh13@gmail.com </p>"},{"location":"contact/#connect-with-me","title":"\ud83d\udd17 Connect with Me","text":"<p>Find me on these platforms:  </p> <ul> <li>GitHub </li> <li>LinkedIn </li> </ul>"},{"location":"contact/#location","title":"\ud83d\udccd Location","text":"<p>I\u2019m based in [India], but open to remote opportunities worldwide.  </p>"},{"location":"resume/","title":"Resume","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/04/24/cached-nix-shell---speed-up-your-nix-workflows/","title":"Cached Nix Shell - Speed Up Your Nix Workflows","text":"","tags":["nix"]},{"location":"blog/2025/04/24/cached-nix-shell---speed-up-your-nix-workflows/#intro","title":"Intro","text":"<p>Nix offers a way to create and run reproducible interpreted scripts. At Valkyrie, we use this to safely execute user-submitted code inside containers. While Nix provides excellent reproducibility, the startup time can be frustratingly slow. When optimizing our execution pipeline, I discovered the Cached Nix Shell project, which has been a game-changer for our performance.</p>","tags":["nix"]},{"location":"blog/2025/04/24/cached-nix-shell---speed-up-your-nix-workflows/#what-is-cached-nix-shell","title":"What is Cached Nix Shell?","text":"<p>Cached Nix Shell is a project by xzfc that addresses the startp time of nix shells by caching environment variables set by nix-shell. This significantly reduces startup time for scripts that use the same dependencies across multiple runs.</p>","tags":["nix"]},{"location":"blog/2025/04/24/cached-nix-shell---speed-up-your-nix-workflows/#how-it-works","title":"How it works","text":"<ol> <li>It stores the environment variables created by nix-shell during the first run</li> <li>On subsequent executions, it reuses these cached variables instead of re-evaluating everything</li> <li>It employs the <code>LD_PRELOAD</code> technique to track all files accessed during the evaluation phase</li> <li>This tracking enables proper cache invalidation if any inputs have changed</li> </ol> <p>This approach gives you the best of both worlds: Nix's reproducibility with improved performance.</p>","tags":["nix"]},{"location":"blog/2025/04/24/cached-nix-shell---speed-up-your-nix-workflows/#installation","title":"Installation","text":"<pre><code>nix-env -iA nixpkgs.cached-nix-shell\n</code></pre>","tags":["nix"]},{"location":"blog/2025/04/24/cached-nix-shell---speed-up-your-nix-workflows/#usage","title":"Usage","text":"<pre><code>#! /usr/bin/env cached-nix-shell\n#! nix-shell -i bash\n#! nix-shell -p go\n\ngo version\n</code></pre> <p>The first run will take the usual amount of time, but subsequent runs will be fast as long as your dependencies haven't changed.</p>","tags":["nix"]},{"location":"blog/2025/04/24/cached-nix-shell---speed-up-your-nix-workflows/#limitations","title":"Limitations","text":"<p>Unfortunately, I discovered that cached-nix-shell doesn't work properly with language environments that bundle multiple packages. For example:</p> <pre><code>#! nix-shell -p 'python3.withPackages(p: [p.django])'  # This fails with cached-nix-shell\n</code></pre> <p>This limitation affects workflows with Python, Ruby, and similar language environments that need dependencies.</p>","tags":["nix"]},{"location":"blog/2025/04/24/cached-nix-shell---speed-up-your-nix-workflows/#my-solution","title":"My Solution","text":"<p>I decided to fork the project and patch it to support language environments. I've used my Rust skills to modify the implementation to handle these more complex package structures.</p> <p>My fork is still in testing, but I plan to submit a pull request to the original project once I've verified everything works as expected. If you're encountering the same issues, you can try out my patched version:</p> <pre><code>nix-env -if https://github.com/deepakdinesh1123/cached-nix-shell/tarball/master\n</code></pre> <p>I'd love to hear your feedback if you give it a try!</p>","tags":["nix"]},{"location":"blog/2025/05/24/clean-urls-for-valkyrie-sandboxes/","title":"Clean URLs for Valkyrie Sandboxes","text":"","tags":["traefik","docker"]},{"location":"blog/2025/05/24/clean-urls-for-valkyrie-sandboxes/#intro","title":"Intro","text":"<p>Valkyrie offers sandboxes, isolated dev and test environments that can be configured using Nix flakes and controlled via a Python SDK.</p>","tags":["traefik","docker"]},{"location":"blog/2025/05/24/clean-urls-for-valkyrie-sandboxes/#problem","title":"Problem","text":"<p>After adding support for sandboxes, we ran into an annoying problem. The URLs used to access them looked like this: <code>http://192.168.1.1:9090/sandbox</code>. These IP-based URLs were hard to remember and use.</p> <p>I started exploring solutions, but most of them required users to make system-level changes like modifying <code>/etc/hosts</code> or running local DNS servers. That kind of setup added complexity and friction we didn\u2019t want. Then I stumbled upon Dokploy, and while browsing their docs, I found a simple and elegant solution.</p>","tags":["traefik","docker"]},{"location":"blog/2025/05/24/clean-urls-for-valkyrie-sandboxes/#traefik-to-the-rescue","title":"Traefik to the Rescue","text":"<p>Traefik is an open-source application proxy that automatically discovers and routes traffic to your services. No need to maintain static config files, it integrates directly with Docker, Kubernetes, and other orchestration tools to pick up routing rules on the fly.</p> <p>This was exactly what we needed.</p>","tags":["traefik","docker"]},{"location":"blog/2025/05/24/clean-urls-for-valkyrie-sandboxes/#the-fix","title":"The Fix","text":"<p>Here\u2019s how we solved it:</p> <p>We created a shared Docker network that both Traefik and our sandbox containers use. Then, using Docker labels, we configured Traefik to route traffic based on container names.</p> <p>Here\u2019s a sample <code>docker-compose</code> config:</p> <p><pre><code>services:\n  service1:\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.&lt;service_name&gt;.rule=Host(`&lt;service_name&gt;.localhost`)\"\n      - \"traefik.http.routers.&lt;service_name&gt;.entrypoints=http\"\n      - \"traefik.http.routers.&lt;service_name&gt;.service=&lt;service_name&gt;\"\n      - \"traefik.http.services.&lt;service_name&gt;.loadbalancer.server.port=9090\"\n</code></pre> You can customize the hostname, choose entrypoints, and even expose multiple services within the container using different load balancer rules.</p> <p>Now, instead of hard-to-remember IP-based URLs like: <pre><code>http://192.168.1.1:9090/sandbox\n</code></pre></p> <p>We get much cleaner and more intuitive ones like: <pre><code>http://pensive-pike.localhost/sandbox\n</code></pre></p> <p>Way easier to remember and use.</p> <p>This tiny tweak, powered by Traefik and a few Docker labels, dramatically improved the UX for working with Valkyrie sandboxes.</p> <p>You can also use this to avoid publishing container ports to host port and run two instances of postgres easily without having to use two different ports</p>","tags":["traefik","docker"]},{"location":"blog/2025/05/24/clean-urls-for-valkyrie-sandboxes/#bonus","title":"Bonus","text":"<ul> <li>If you already use caddy as your proxy you can check out Caddy Docker Proxy which offers a similar solution.</li> </ul>","tags":["traefik","docker"]},{"location":"blog/2025/03/24/nix-invasion/","title":"Nix Invasion","text":"<p>This blog post will detail my introduction to nix and describe how I am using it today, if you are a software engineer frustrated with setting up environments or a distro hopper who is finally done with finding installation instructions for software in every distro and asking ChatGPT for help when they do not work this blog will convince you to learn nix.</p>","tags":["nix"]},{"location":"blog/2025/03/24/nix-invasion/#intro","title":"Intro","text":"<p>For a long time I was working on a code execution engine based on docker but I abandoned it as I felt that configuring and maintaining docker images would take a lot of effort and space and when I was exploring what project I would work on next I think I heard the word nix from a blog or reddit comment and decieded to give it a try.</p>","tags":["nix"]},{"location":"blog/2025/03/24/nix-invasion/#beginning","title":"Beginning","text":"<p>I naively thought that this would be a replacement for brew or apt but as I started reading the docs I realised that it was going to take me a lot of time to understand everything about nix when I learned that nix is based on the PHD thesis written by Eelco Dolstra (the creator of nix). </p> <p>Every blog post and documentation section I read described 5 different ways to do the same thing (there are two ways of just installing nix on linux). On top of that there were a lot of concepts that I had to learn and understand how they work. I gave up on learning nix a lot of times but I went back everytime beacuse of what nix promised. I found this brilliant blog by Ian henry that helped me a lot.</p>","tags":["nix"]},{"location":"blog/2025/03/24/nix-invasion/#experimenting-and-learning","title":"Experimenting And Learning","text":"<p>I started experimenting with every command and concept that I could use and I started to see the bigger picture of what nix is about. Once I was able to get an overview of the entire ecosystem of nix it became much clearer and I was able to create what I exactly wanted using nix.</p> <p>I started learning about shells, flakes, packaging, home-manager and tests and it completely transformed the way I setup environments for my projects and package them and the full scale invasion of nix started.</p>","tags":["nix"]},{"location":"blog/2025/03/24/nix-invasion/#the-power-of-the-sun-in-the-palm-of-my-hands","title":"The Power Of The Sun In The Palm Of My Hands","text":"<p>I now explicitly use nix in almost all of my go, python and typescript projects for creating a development enviornment and packaging projects. To quickly try out any new tool that I want to try I create nix-shells or use flakes and I manage my entire system config with home-manager.</p> <p>I can't even remember the last time I checked the installation instructions for installing any of the applications I use on a regular basis. I just keep changing my home-manager config to use a different shell or a different editor wihout worrying if I have messed up my dotfiles or I have not proprely uninstalled something.</p>","tags":["nix"]},{"location":"blog/2025/03/24/nix-invasion/#final-thoughts","title":"Final Thoughts","text":"<p>Learning nix takes time and patience but the end result is well worth it. Feel free to give it a try, if you face any issues don't hesitate to hit me up.</p>","tags":["nix"]},{"location":"blog/2025/05/05/python-monorepos-with-uv/","title":"Python Monorepos with UV","text":"<p>If you've spent any time as a Python developer lately, you've definitely heard of UV - the blazing-fast Python package and project manager that's solving so many problems in the Python ecosystem.  At Valkyrie, we initially started using UV in our Python SDK. But when we began working on an MCP server I found myself wondering how to effectively manage multiple Python projects in the same repository.</p>","tags":["python"]},{"location":"blog/2025/05/05/python-monorepos-with-uv/#the-monorepo-headaches","title":"The Monorepo Headaches","text":"<p>Anyone who's tried housing multiple Python projects in a single repo has likely run into these frustrations:</p> <ul> <li>Creating separate virtual environments for each project quickly becomes wasteful - you end up with duplicate dependencies everywhere</li> <li>When one project needs to depend on another project in the same repo, the dependency management gets messy fast</li> <li>You find yourself copy-pasting nearly identical <code>setup.py</code> or <code>pyproject.toml</code> configs across projects</li> </ul> <p>These pain points had me searching for a better way to structure our codebase.</p>","tags":["python"]},{"location":"blog/2025/05/05/python-monorepos-with-uv/#enter-uv-workspaces","title":"Enter UV Workspaces","text":"<p>Thankfully, UV offers workspaces - an elegant solution to all these problems. You can define each project as a workspace member and manage them together, which simplifies your workflow.</p> <p>Getting started with workspaces in an existing project is straightforward. You can run:</p> <pre><code>uv init &lt;project_name&gt;\n</code></pre> <p>Or you can manually edit the <code>pyproject.toml</code> of your root project to include new members like this:</p> <pre><code>[project]\nname = \"python-project\"\nversion = \"0.1.0\"\ndescription = \"python-project\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.12\"\ndependencies = [\"project1\", \"project2\"]\n\n[tool.uv.sources]\nproject2 = { workspace = true }\nproject1 = { workspace = true }\n\n[tool.uv.workspace]\nmembers = [\"project1\", \"&lt;path&gt;/project2\"]\n</code></pre> <p>The beauty of this approach is that you can now: - Define dependencies at either the workspace level (shared across all projects) or at the individual project level - Easily declare one project as a dependency of another, and UV will handle building everything in the right order - Maintain a single virtual environment while still keeping your projects logically separated</p> <p>For example, here's how you'd set up project1 to depend on project2 within the workspace:</p> <pre><code>[project]\nname = \"project1\"\nversion = \"0.1.0\"\ndescription = \"python project\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.12\"\ndependencies = [\n \"project2\",\n]\n\n[tool.uv.sources]\nproject2 = { workspace = true }\n</code></pre> <p>When you create an environment, UV builds all the projects and resolves the dependencies correctly.</p> <p>You can check out how we use UV workspaces at valkyrie here</p> <p>Word of Caution:  Python doesn't provide true dependency isolation, so UV can't guarantee that a package uses only its declared dependencies and nothing else. With workspaces specifically, there's no mechanism preventing packages from importing dependencies declared by another workspace member. So make sure to use workspaces only when you are certain that member projects don't have conflicting dependencies and they are related to each other and share common dependencies</p> <p>Have you tried using UV workspaces for your Python projects yet? I'd love to hear about your experience.</p>","tags":["python"]},{"location":"projects/","title":"Projects","text":""},{"location":"projects/#google-summer-of-code","title":"Google Summer Of Code","text":"<p>Worked with the the django organisation during Google summer of code 2022 to improve benchmarking in django</p>"},{"location":"projects/#valkyrie","title":"Valkyrie","text":"<p>A code execution and sandbox management engine that allows users to run code in multiple programming languages, with language and system dependencies. This engine also facilitates the creation of sandboxes, with integrated vscode server and essential services such as PostgreSQL and Redis, simplifying the setup of complex development environments.</p>"},{"location":"projects/#valhalla","title":"Valhalla","text":"<p>Valhalla combines ChatGPT with Valkyrie to let you run code directly from your chats.</p>"},{"location":"projects/#alfred","title":"Alfred","text":"<p>An MCP server to enhance your home-manager and nix-darwin config</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/tech/","title":"tech","text":""}]}